---
title: OFDM_802.11a学习----短训练序列检测
date: 2022-06-09 14:08:35
tags: ["OFDM", "SDR", "ZYNQ"]
categories: OFDM
comment: true
mathjax: true
---
# 1. 前言
在前面实现了802.11a的发送数据包的生成，从而完成了802.11a的发送数据通路。在上面实现了数据的加扰，卷积编码，交织，OFDM星座图映射，IFFT的转换和添加循环前缀，添加前导码LTS，STS等操作。
相较于802.11a的发送数据链路，接受数据链路的难度相较于发送链路会大很多，里面涉及了许多同步的算法的设置，频偏的校正等操作。
从这篇博客开始，我将会记录在学习802.11a数据解调的过程中所学习到的东西。
<!--more-->

# 2. 短训练序列的检测原理
在一个802.11a的数据帧当中，首先是10个短训练序列，每个短训练序列的长度是0.8us，在解调802.11a的帧数据的时候，可以使用短训练序列来进行包检测。
![PPDU具体结构](OFDM-802-11a学习-短训练序列检测/PPDU具体结构.png)
在前面实现OFDM发送机的时候，我们可以知道，这10个短训练序列是重复的，因此在接收端可以对接受到的信号进行相关来检测相关峰，因为当短训练序列正好对上的时候，根据短训练序列的特性，相关的结果将呈现一个较大的值。
一个短训练序列的周期是0.8us，在20M采样率的情况下，一个段训练序列需要16个采样周期。
$$
corr(i) = \frac{\sum_{i=0}^{N}s[i]\times \overline{s[i+16]}}{\sum_{i=0}^{N}s[i]\times \overline{s[i]}}
$$

其中 $\overline{s[i+16]}$ 是之后16个采样点的共轭， $\overline{s[i]}$ 是当前采样点的共轭。在进行相关的时候，到了段训练序列的值，那么当前相关出来的结果应该接近1。
其中短训练序列的时域波形如下：
![短训练序列时域波形](OFDM-802-11a学习-短训练序列检测/短训练序列时域波形.png)

```matlab
clc;
clear all;
close all;

load('RxIQ.mat');
rx_sample = double(RxSave);

for i = 1:1000
    if (sum(abs(rx_sample(i:i+15).^2)) == 0)
        corr(i) = 0;
    else
        corr(i) = abs(sum(rx_sample(i:i+15).*conj(rx_sample(i+16:i+16+15))))/abs(sum(rx_sample(i:i+15).*conj(rx_sample(i:i+15))));
    end
end

figure(1);
plot(real(rx_sample(1:1000))/max(abs(real(rx_sample(1:1000)))));
hold on;
plot(corr);
```
在进行相关之后，可以看到当前的相关结果会出现一个持续一段时间的相关峰。
![短训练序列检测](OFDM-802-11a学习-短训练序列检测/短训练序列检测.png)
在实际的FPGA实现的时候，我们就可以根据这个算法来进行设计，实际上，检测短训练序列还需要加入一些额外的条件，才能保证不会发生误判。
- 短训练序列出现相关峰，并且要连续地保持足够长的时间，由于有10个短训练序列，一个短训练序列的周期是0.8us，在20M采样率下短训练序列一共有160个采样点。因此首先需要满足检测到有连续100个采样点满足相关峰地值接近1。
- 可以看到在相关峰超过阈值的之后，短训练序列输入的信号依然会有正有负，因此我们可以计数当前检测到的数据的正负的个数，并且当正数和负数都大于一定阈值的时候，才判定当前检测到了短训练序列。

# 3. 短训练序列检测的实现
在前面了解了短训练序列的原理，别看在matlab里面就是一行代码的事情，想要用FPGA来实现，需要将这一行代码一步一步地拆开，转换到对应的硬件资源上，才能最终实现包的检测。
我们可以再回顾一下这个算法：
从这里不难看出，在设计的时候，需要进行以下的操作，分别是对数据进行延时16拍，对当前数据和延时16拍之后的数据取共轭，进行复数乘法，求累加和，分子分母进行比较。
$$
corr(i) = \frac{\sum_{i=0}^{N}s[i]\times \overline{s[i+16]}}{\sum_{i=0}^{N}s[i]\times \overline{s[i]}}
$$

因此在实现上述算法的过程的时候，我们需要分别实现各个模块的操作。
上面这个算法的硬件实现方法，可以参考如下框图。
![短训练序列检测](OFDM-802-11a学习-短训练序列检测/算法硬件实现.png)
主要信号可以分为两路，分别对应上面的公式当中的分子和分母的数据。
首先可以看分子上这一路数据。
- 首先对输入的信号进行延时16个采样点
- 然后对延时模块输出的信号进行取共轭
- 然后将当前的采样点和延时16采样点之后的数据进行复数乘法
- 经过复数乘法之后的数据需要在累加一段时间，在这里我们设计累加16个采样点，也就是刚好一个STS的长度
- 然后使用一个幅度估计的算法来计算出当前的复数信号的模，也就是我们计算出的分子上的结果。

对于分母上的过程，其处理方式和分子的类似
- 然后对当前采样点的信号进行取共轭
- 然后将当前的采样点和其共轭后的数据进行复数乘法
- 经过复数乘法之后的数据需要在累加一段时间，在这里我们设计累加16个采样点，也就是刚好一个STS的长度
- 然后使用一个幅度估计的算法来计算出当前的复数信号的模，也就是我们计算出的分母上的结果。

最后，我们需要比较分子和分母上的这两个模的大小，当分子上的模大于 3/4分母时，可以判定当前出现了短训练序列出现了相关峰。出现相关峰之后，还需要进行进一步的处理才能判断当前的确检测到了短训练序列。

- 出现相关峰之后，首先我们得保证相关峰的结果需要保持100个连续的采样点。
- 其次我们得保证，在相关峰持续的时候，输入的实际的采样点的值，既有正数也有复数，并且正负数的个数都需要大于一定的阈值，比如30，因为短训练序列的正负数是基本一致的。

## 3.1 延时模块

延时模块的设计思路如下：
当采样点进入延时模块时，首先将数据写入到RAM当中，当RAM当中已经存有需要延时的采样点个数之后，拉高一个ready信号，在ready信号拉高之后，再进来一个采样点，就会把地址0的数据读出，并且将这个新写入的数据存到地址0当中，然后按着这个顺序依次进行，这样就能够完成延时需要的时钟周期了。
![delay_sample](OFDM-802-11a学习-短训练序列检测/delay_sample.svg)
该部分的代码如下：

```verilog
module sample_delay #(
    parameter DATA_WIDTH = 32,
    parameter DELAY_DEEPTH = 16
) ( 
    input   wire                        clk                     ,   
    input   wire                        rst                     ,
    input   wire                        enable                  ,
    input   wire                        sample_in_valid         ,    
    input   wire [DATA_WIDTH-1:0]       sample_in               ,
    output  reg                         sample_delay_out_valid  ,
    output  wire [DATA_WIDTH-1:0]       sample_delay_out
);
    //  The following function calculates the address width based on specified RAM depth
    function integer clogb2;
    input integer depth;
        for (clogb2=0; depth>0; clogb2=clogb2+1)
        depth = depth >> 1;
    endfunction

    //====================================================
    // internal signals and resgiters
    //====================================================
    reg                                 delay_ready ; // delay enough samples 
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    cnt_delay   ; // delay counter

    wire                                wr_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    wr_ram_addr ;
    wire[DATA_WIDTH-1:0]                wr_ram_data ;

    wire                                rd_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    rd_ram_addr ;
    wire[DATA_WIDTH-1:0]                rd_ram_data ;


    //----------------cnt_delay------------------
    always @(posedge clk) begin
        if (rst == 1'b1) begin
            cnt_delay <= 'd0;
        end
        else if (enable == 1'b1) begin
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1)begin
                cnt_delay <= 'd0;
            end
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1)begin
                cnt_delay <= cnt_delay + 1'b1;
            end
        end
        else begin
            cnt_delay <= 'd0;
        end
    end

    //----------------delay_ready------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            delay_ready <= 1'b0;
        end
        else if (enable == 1'b1) begin
            if (delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1) begin
                delay_ready <= 1'b1;
            end
        end
        else begin
            delay_ready <=  1'b0;
        end
    end

    //----------------wr_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            wr_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (samplmodule sample_delay #(
    parameter DATA_WIDTH = 32,
    parameter DELAY_DEEPTH = 16
) ( 
    input   wire                        clk                     ,   
    input   wire                        rst                     ,
    input   wire                        enable                  ,
    input   wire                        sample_in_valid         ,    
    input   wire [DATA_WIDTH-1:0]       sample_in               ,
    output  reg                         sample_delay_out_valid  ,
    output  wire [DATA_WIDTH-1:0]       sample_delay_out
);
    //  The following function calculates the address width based on specified RAM depth
    function integer clogb2;
    input integer depth;
        for (clogb2=0; depth>0; clogb2=clogb2+1)
        depth = depth >> 1;
    endfunction

    //====================================================
    // internal signals and resgiters
    //====================================================
    reg                                 delay_ready ; // delay enough samples 
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    cnt_delay   ; // delay counter

    wire                                wr_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    wr_ram_addr ;
    wire[DATA_WIDTH-1:0]                wr_ram_data ;

    wire                                rd_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    rd_ram_addr ;
    wire[DATA_WIDTH-1:0]                rd_ram_data ;


    //----------------cnt_delay------------------
    always @(posedge clk) begin
        if (rst == 1'b1) begin
            cnt_delay <= 'd0;
        end
        else if (enable == 1'b1) begin
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1)begin
                cnt_delay <= 'd0;
            end
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1)begin
                cnt_delay <= cnt_delay + 1'b1;
            end
        end
        else begin
            cnt_delay <= 'd0;
        end
    end

    //----------------delay_ready------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            delay_ready <= 1'b0;
        end
        else if (enable == 1'b1) begin
            if (delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1) begin
                delay_ready <= 1'b1;
            end
        end
        else begin
            delay_ready <=  1'b0;
        end
    end

    //----------------wr_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            wr_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (sample_in_valid == 1'b1 && wr_ram_addr == DELAY_DEEPTH - 1) begin
                wr_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1) begin
                wr_ram_addr <= wr_ram_addr + 1'b1;
            end
        end
        else  begin
            wr_ram_addr <=  'd0;
        end
    end

    assign wr_ram_en = sample_in_valid;
    assign wr_ram_data = sample_in;


    simple_2port_ram#(
        .RAM_WIDTH       ( DATA_WIDTH ),
        .RAM_DEPTH       ( DELAY_DEEPTH ),
        .RAM_PERFORMANCE ( "LOW_LATENCY" ),
        .INIT_FILE       ( "" )
    )u_simple_2port_ram(
        .addra           ( wr_ram_addr     ),
        .addrb           ( rd_ram_addr     ),
        .dina            ( wr_ram_data     ),
        .clka            ( clk             ),
        .clkb            ( clk             ),
        .wea             ( wr_ram_en       ),
        .enb             ( rd_ram_en       ),
        .rstb            ( rst             ),
        .regceb          ( 1'b1            ),
        .doutb           ( rd_ram_data     )
    );


    //----------------rd_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            rd_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (sample_in_valid == 1'b1 && delay_ready == 1'b1 && (rd_ram_addr == DELAY_DEEPTH - 1)) begin
                rd_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1 && delay_ready == 1'b1) begin
                rd_ram_addr <= rd_ram_addr + 1'b1;
            end
        end
        else  begin
            rd_ram_addr <=  'd0;
        end
    end

    assign rd_ram_en = sample_in_valid & delay_ready;

    //----------------sample_delay_out_valid------------------
    always @(posedge clk) begin
        sample_delay_out_valid <= rd_ram_en;
    end

    assign sample_delay_out = rd_ram_data;
    
endmodulee_in_valid == 1'b1 && wr_ram_addr == DELAY_DEEPTH - 1) begin
                wr_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1) begin
                wr_ram_addr <= wr_ram_addr + 1'b1;
            end
        end
        else  begin
            wr_ram_addr <=  'd0;
        end
    end

    assign wr_ram_en = sample_in_valid;
    assign wr_ram_data = sample_in;


    simple_2port_ram#(
        .RAM_WIDTH       ( DATA_WIDTH ),
        .RAM_DEPTH       ( DELAY_DEEPTH ),
        .RAM_PERFORMANCE ( "LOW_LATENCY" ),
        .INIT_FILE       ( "" )
    )u_simple_2port_ram(
        .addra           ( wr_ram_addr     ),
        .addrb           ( rd_ram_addr     ),
        .dina            ( wr_ram_data     ),
        .clka            ( clk             ),
        .clkb            ( clk             ),
        .wea             ( wr_ram_en       ),
        .enb             ( rd_ram_en       ),
        .rstb            ( rst             ),
        .regceb          ( 1'b1            ),
        .doutb           ( rd_ram_data     )
    );


    //----------------rd_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            rd_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (sample_in_valid == 1'b1 && delay_ready == 1'b1 && (rd_ram_addr == DELAY_DEEPTH - 1)) begin
                rd_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1 && delay_ready == 1'b1) begin
                rd_ram_addr <= rd_ram_addr + 1'b1;
            end
        end
        else  begin
            rd_ram_addr <=  'd0;
        end
    end

    assign rd_ram_en = sample_in_valid & delay_ready;

    //----------------sample_delay_out_valid------------------
    always @(posedge clk) begin
        sample_delay_out_valid <= rd_ram_en;
    end

    assign sample_delay_out = rd_ram_data;
    
endmodule
```

## 2. 求累加和模块
求累加和模块的时序设计如下所示：
![accumulate_average](OFDM-802-11a学习-短训练序列检测/accumulate_average.svg)
该模块的设计思路如下：
输入的采样点，在采样点有效的情况下进行累加，并将输入的采样点写入到RAM当中，当累加到需要的采样点个数的时候，比如16，会拉高这个ready信号，ready信号拉高之后，再来一个采样点，将RAM当中的第一个采样点读出，并且将新进入的采样点写入。与此同时累加和再原来的基础上，加上新进来的采样点的值并且减去从RAM当中读出的值，也就16个采样点之前的值，这样就能够保证求取一个长度为16的窗口当中的累加和了。

该部分的实现代码如下：
```verilog
// -----------------------------------------------------------------------------
// Copyright (c) 2019-2022 All rights reserved
// -----------------------------------------------------------------------------
// Author 	 : WCC 1530604142@qq.com
// File   	 : accumulate_avg
// Create 	 : 2022-05-19
// Revise 	 : 2022-
// Editor 	 : Vscode, tab size (4)
// Functions : Accumulate the input data and calculate the average value
// 			   
// -----------------------------------------------------------------------------
module accumulate_avg #(
    parameter DATA_WIDTH = 32,
    parameter DELAY_DEEPTH = 16
) ( 
    input   wire                        clk                     ,   
    input   wire                        rst                     ,
    input   wire                        enable                  ,
    input   wire                        sample_in_valid         ,    
    input   wire [DATA_WIDTH-1:0]       sample_in               ,
    output  reg                         acc_avg_out_valid       ,
    output  reg  [DATA_WIDTH-1:0]       acc_avg_out
);
    //  The following function calculates the address width based on specified RAM depth
    function integer clogb2;
    input integer depth;
        for (clogb2=0; depth>0; clogb2=clogb2+1)
        depth = depth >> 1;
    endfunction

    //====================================================
    // parameter define
    //====================================================
    localparam EXT_WDITH = clogb2(DELAY_DEEPTH-1);

    //====================================================
    // internal signals and resgiters
    //====================================================
    reg                                 delay_ready ; // delay enough samples 
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    cnt_delay   ; // delay counter
    reg                                 sample_in_valid_dly1,sample_in_valid_dly2;
    
    reg                                 delay_ready_dly1, delay_ready_dly2, delay_ready_dly3;

    wire                                wr_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    wr_ram_addr ;
    wire[DATA_WIDTH-1:0]                wr_ram_data ;

    wire                                rd_ram_en   ;
    reg [clogb2(DELAY_DEEPTH-1)-1:0]    rd_ram_addr ;
    wire[DATA_WIDTH-1:0]                rd_ram_data ;
    reg                                 rd_ram_valid;

    reg [DATA_WIDTH + EXT_WDITH-1:0]    acc_window  ;
    reg                                 acc_window_valid;
    reg [DATA_WIDTH-1:0]                acc_new     ;
    wire[DATA_WIDTH-1:0]                acc_old     ;
    wire[DATA_WIDTH + EXT_WDITH-1:0]    acc_ext_new ;
    wire[DATA_WIDTH + EXT_WDITH-1:0]    acc_ext_old ;




    //----------------cnt_delay------------------
    always @(posedge clk) begin
        if (rst == 1'b1) begin
            cnt_delay <= 'd0;
        end
        else if (enable == 1'b1) begin
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1)begin
                cnt_delay <= 'd0;
            end
            if(delay_ready == 1'b0 && sample_in_valid == 1'b1)begin
                cnt_delay <= cnt_delay + 1'b1;
            end
        end
        else begin
            cnt_delay <= 'd0;
        end
    end

    //----------------delay_ready------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            delay_ready <= 1'b0;
        end
        else if (enable == 1'b1) begin
            if (delay_ready == 1'b0 && sample_in_valid == 1'b1 && cnt_delay == DELAY_DEEPTH -1) begin
                delay_ready <= 1'b1;
            end
        end
        else begin
            delay_ready <=  1'b0;
        end
    end

    //----------------wr_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            wr_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (sample_in_valid == 1'b1 && wr_ram_addr == DELAY_DEEPTH - 1) begin
                wr_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1) begin
                wr_ram_addr <= wr_ram_addr + 1'b1;
            end
        end
        else  begin
            wr_ram_addr <=  'd0;
        end
    end

    assign wr_ram_en = sample_in_valid;
    assign wr_ram_data = sample_in;

    always @(posedge clk ) begin
        if (rst==1'b1) begin
            sample_in_valid_dly1 <= 1'b0;
            sample_in_valid_dly2 <= 1'b0;
            delay_ready_dly1 <= 1'b0;
            delay_ready_dly2 <= 1'b0;
            delay_ready_dly3 <= 1'b0;
        end
        else  begin
            sample_in_valid_dly1 <=  sample_in_valid;
            sample_in_valid_dly2 <=  sample_in_valid_dly1;
            delay_ready_dly1 <= delay_ready;
            delay_ready_dly2 <= delay_ready_dly1;
        end
    end


    simple_2port_ram#(
        .RAM_WIDTH       ( DATA_WIDTH ),
        .RAM_DEPTH       ( DELAY_DEEPTH ),
        .RAM_PERFORMANCE ( "LOW_LATENCY" ),
        .INIT_FILE       ( "" )
    )u_simple_2port_ram(
        .addra           ( wr_ram_addr     ),
        .addrb           ( rd_ram_addr     ),
        .dina            ( wr_ram_data     ),
        .clka            ( clk             ),
        .clkb            ( clk             ),
        .wea             ( wr_ram_en       ),
        .enb             ( rd_ram_en       ),
        .rstb            ( rst             ),
        .regceb          ( 1'b1            ),
        .doutb           ( rd_ram_data     )
    );


    //----------------rd_ram_addr------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            rd_ram_addr <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (sample_in_valid == 1'b1 && delay_ready == 1'b1 && (rd_ram_addr == DELAY_DEEPTH - 1)) begin
                rd_ram_addr <= 'd0;
            end
            else if (sample_in_valid == 1'b1 && delay_ready == 1'b1) begin
                rd_ram_addr <= rd_ram_addr + 1'b1;
            end
        end
        else  begin
            rd_ram_addr <=  'd0;
        end
    end

    assign rd_ram_en = sample_in_valid & delay_ready;

    //----------------rd_ram_valid------------------
    always @(posedge clk) begin
        rd_ram_valid <= rd_ram_en;
    end

    //----------------acc_new/old------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            acc_new <= 'd0;
        end
        else if (enable == 1'b1) begin
            if (delay_ready == 1'b1 && sample_in_valid == 1'b1) begin
                acc_new <= sample_in;
            end
        end
        else  begin
            acc_new <=  'd0;
        end
    end

    assign acc_old = rd_ram_data;

    assign acc_ext_new = {{EXT_WDITH{acc_new[DATA_WIDTH-1]}}, acc_new};
    assign acc_ext_old = {{EXT_WDITH{acc_old[DATA_WIDTH-1]}}, acc_old};
    
    //----------------acc_window------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            acc_window <= 'd0;
        end
        else if (enable == 1'b1) begin
            if(delay_ready == 1'b0)begin
                if(sample_in_valid == 1'b1)begin
                    acc_window <= acc_window + {{EXT_WDITH{sample_in[DATA_WIDTH-1]}},sample_in};
                end
            end
            else begin
                if (rd_ram_valid == 1'b1) begin
                   acc_window <= acc_window - acc_ext_old + acc_ext_new; 
                end
            end
        end
        else  begin
            acc_window <=  'd0;
        end
    end

    //----------------acc_window_valid------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            acc_window_valid <= 1'b0;
        end
        else if (enable == 1'b1) begin
            if (delay_ready == 1'b1 ) begin
                acc_window_valid <= rd_ram_valid;
            end
        end
        else  begin
            acc_window_valid <=  1'b0;
        end
    end

    //----------------avg_out_valid------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            acc_avg_out_valid <= 1'b0;
        end
        else if (enable == 1'b1) begin
            // latency 2 beat
            acc_avg_out_valid <= delay_ready ? acc_window_valid | (~delay_ready_dly2 & delay_ready_dly1) : sample_in_valid_dly2;
        end
        else  begin
            acc_avg_out_valid <= 1'b0;
        end
    end

    //----------------acc_avg_out------------------
    always @(posedge clk ) begin
        if (rst==1'b1) begin
            acc_avg_out <= 'd0;
        end
        else if (enable == 1'b1) begin
            acc_avg_out <= acc_window[DATA_WIDTH + EXT_WDITH-1: EXT_WDITH];
        end
        else  begin
            acc_avg_out <=  'd0;
        end
    end
    
endmodule
```